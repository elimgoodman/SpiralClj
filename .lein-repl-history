  (:require [noir.server :as server])
(require noir.server)
(noir.server)
(require 'noir.server)
(noir/server start)
(noir.server start)
(require '[noir.server :as server])
(server)
(server/start)
(server/start 5000)
(server/stop)
(server/stop 5000)
(require '[noir.server :as server])
(def s (server/start 5000))
s
(server/stop s)
(def foo nil)
(foo)
foo
(set! foo 1)
(ref bar (atom nil))
(def server (ref nil))
(defn foo [] (println "hi"))
(foo)
#'foo
(#'foo)
(var foo)
(def a {0 "foo" 1 "bar"})
a
(first a)
(keys a)
(vals a)
(def a {:foo "bar" :baz "beep"})
(find)
find
(find a :foo)
a
(def a [{:foo "bar" :baz "beep"}, {:foo "burp"}])
(filter a (fn [f] (= (:foo f) "bar")))
(filter (vals a) (fn [f] (= (:foo f) "bar")))
(def a [{:foo "bar" :baz "beep"}, {:foo "burp"}])
(filter (fn [f] (= (:foo f) "bar")) a)
(head (filter (fn [f] (= (:foo f) "bar")) a))
(first (filter (fn [f] (= (:foo f) "bar")) a))
(first (filter (fn [f] (= (:foo f) "barrrr")) a))
#()
#([f] (+ 1 2))
#(f (+ 1 2))
# (+ 1 2))
#(+ 1 1)
a
(first #(= (:foo %) "bar") a))
(filter #(= (:foo %) "bar") a)
(declare foo)
foo
(def foo "a")
(def a {:foo {0 {:beep "boop"}}})
a
(require '[fleet :as f])
f
(require '[fleet :as f])
f
(require '[fleet :as f])
(f)
f/fleet
(f/fleet "foo <( bar )>")
(f/fleet [bar] "foo <( bar )>")
(def a (f/fleet [bar] "foo <( bar )>"))
a
(a "beep")
(prinln (a "beep")
)
(println (a "beep"))
((def footer (fleet "<p>&copy; <(year (now))> Your Company</p>")
))
(def footer (fleet "<p>&copy; <(year (now))> Your Company</p>"))
(def footer (f/fleet "<p>&copy; <(year (now))> Your Company</p>"))
(def header (f/fleet [title] "<head><title><(str title)></title></head>"))
(println (header "Main Page"))
(require '[hiccup.core :as h])
(h/html [:style])
(h/html [:style {:type "text/css"])
(h/html [:style {:type "text/css"}])
(count [])
(def a ["foo" "bar"])
(some #(= "foo" %) a)
(require '[fleet :as f])
(f/fleet [a b] "<(str a)><(str b)>")
((f/fleet [a b] "<(str a)><(str b)>") 1 2)
(str ((f/fleet [a b] "<(str a)><(str b)>") 1 2))
(str ((f/fleet [a b] "<(str a)>") 1 2))
(str ((f/fleet [a] "<(str a)>") 1 2))
(str ((f/fleet [a] "<(str a)>") 1))
a
(str ((f/fleet [aaa] "<(str a)>") 1))
(str ((f/fleet [aaa] "<(str aaa)>") 1))
(conj ["a"] ["b"])
(cons ["a"] ["b"])
(concat ["a"] ["b"])
(distinct ["a" "a" "b"])
(ns foo)
(def a (ns foo))
a
(re-find #"<\(include \"[^\"+]\")>" "goo")
(re-find #"<\(include \"[^\"+]\"\)>" "goo")
(re-find #"<\(include \"[^\"+]\"\)>" "foo<(include \"boop\")>")
(re-fine #'<\(include "(.+)"\)>' '<(include "boop")>)
"hello
"
'hello'
(re-fine #"<\(include \"(.+)\"\)>" "<(include \"boop\")>")
(re-find #"<\(include \"(.+)\"\)>" "<(include \"boop\")>")
(re-find #"<\(include \"(.+)\"\)>" "foo<(include \"boop\")>")
(re-find #"<\(include \"(.+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
(re-find #"<\(include \"([^"]+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
"
(re-find #"<\(include \"([^\"]+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
(re-seq #"<\(include \"([^\"]+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
(second [1 2])
(partial + 1)
((partial + 1) 2)
(concat [1] [2] [3])
(def a [{:a [1 2 3]} {:a [4, 5, 6]}])
a
(reduce #(concat (:a %)) a)
(reduce conj a)
(reduce #(conj (:a %1) (:a %2)) a)
(reduce #(concat (:a %1) (:a %2)) a)
(require '[clojure.contrib.json :as f])
(require '[clojure.contrib.json :as j])
(require '[data.json :as j])
(require '[clojure.data.json :as j])
(doc print)
(vals {:a 1})
(require '[clojure.data.json :as j])
(def a 'hello')
a
(def a "{\"foo\": 1}")
a
(j/read-str a)
(def b (j/read-str a))
b
(:foo b)
(def b (j/read-str a :key-fn keyword))
b
(require '[clabango.parser :as p])
p
(require '[clabango.parser])
clabango.parser
(p/render "{{foo}}" {:foo 1})
(p/render "{{foo.bar}}" {:foo {:bar 2})
(p/render "{{foo.bar}}" {:foo {:bar 2}})
(def f (clojure.java.io/file "test-project"))
d
f
(file-seq f)
(def a (first (file-seq f)))
a
(.getPath a)
(map #(.getPath %) (file-seq f))
(map #(.getName %) (file-seq f))
(help)
(doc replace)
(p/render "{{foo.bar}}" {:foo {:bar 2}})
p
(p)
(p/parse "{{foo.bar}}" {:foo {:bar 2}})
(require '[clabango.tags :as t])
t
(t/deftemplatetag "foo" [nodes context]
(println nodes))
(p/parse "{% foo bar %}" {:foo {:bar 2}})
(p/render "{% foo bar %}" {:foo {:bar 2}})
(p/render "{% foo pages as routes %}" {:foo {:bar 2}})
(p/render "{% foo :pages as routes %}" {:foo {:bar 2}})
(t/deftemplatetag "foo" [nodes context]
{:string "beep"})
(p/render "{% foo :pages as routes %}" {:foo {:bar 2}})
(doc take-n)
(help)
(take-n)
{:string "beep"})
(require '[clojure.string :as s])
(s/split #" " "a b c")
(doc s/split)
(s/split "a b c" #" ")
(doc nth)
(nth 2 [1 2 3])
(nth [1, 2, 3] 2)
(p/render "{% for page in instances.pages %}beep{% endfor %}" {:instances {:pages [1 2 3 4]}})
(t/deftemplatetag "foo" [nodes context]
(println context))
(p/render "{% for page in instances.pages %}{% foo %}{% endfor %}" {:instances {:pages [1 2 3 4]}})
(def a {:foo "bar"})
((keyword "foo") a)
(def page-route-template "(defpage \"{{values.url}}\" [] (get-template \"{{name}}\"))")
(p/parse page-route-template)
(doc p/parse)
(p/parse page-route-template {})
(println page-route-template)
(def a "{{foo}} and the other {{bar}}")
(p/parse a {})
(p/parse a {:foo "hello"})
(p/string->ast a)
(p/string->ast page-route-template)
(string :foo)
:foo
(str :foo)
(t/deftemplatetag "foo" [nodes context]
)
(def a '(foo as bar with baz=beep))
a
(nth a 4)
(apply str a)
(string/join
)
(s/join)
(doc s/join)
(s/join " " a)
(def b (s/join " " a))
(re-find #"as (\w+)" b)
(re-find #"with (\w+)" b)
(re-find #"with ([^\s]+)" b)
b
(def b "foo as bar with baz=beep,boop=bip")
(re-find #"with ([^\s]+)" b)
(def b "foo as bar with baz=beep, boop=bip")
(re-find #"with ([^\s]+)" b)
(re-find #"[^\s]+" b)
(eval 2)
(eval "foo")
(read-string "foo")
(read-string ":foo")
(eval :foo)
(eval bar)
(read-string "\"foo\"")
(re-find #"[^\s]+" b)
(re-find #"([^\s])+" b)
(re-find #"([^\s]+)" b)
(re-find #"^([^\s]+)" b)
(re-find #"as ([^\s]+)" b)
(re-find #"with (.+)$" b)
(re-find #"with (.+)$" "foo as bar")
(s/split)
(doc s/split)
(def d "a=b,c=d")
(s/split d #",")
(def d "a=b, c=d")
(s/split d #",")
(s/split "a=b" #",")
(map (-> inc inc) [1 2 3])
(inc 2)
(map (partial (-> inc inc)) [1 2 3])
((-> inc inc) 1)
