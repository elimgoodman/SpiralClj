  (:require [noir.server :as server])
(require noir.server)
(noir.server)
(require 'noir.server)
(noir/server start)
(noir.server start)
(require '[noir.server :as server])
(server)
(server/start)
(server/start 5000)
(server/stop)
(server/stop 5000)
(require '[noir.server :as server])
(def s (server/start 5000))
s
(server/stop s)
(def foo nil)
(foo)
foo
(set! foo 1)
(ref bar (atom nil))
(def server (ref nil))
(defn foo [] (println "hi"))
(foo)
#'foo
(#'foo)
(var foo)
(def a {0 "foo" 1 "bar"})
a
(first a)
(keys a)
(vals a)
(def a {:foo "bar" :baz "beep"})
(find)
find
(find a :foo)
a
(def a [{:foo "bar" :baz "beep"}, {:foo "burp"}])
(filter a (fn [f] (= (:foo f) "bar")))
(filter (vals a) (fn [f] (= (:foo f) "bar")))
(def a [{:foo "bar" :baz "beep"}, {:foo "burp"}])
(filter (fn [f] (= (:foo f) "bar")) a)
(head (filter (fn [f] (= (:foo f) "bar")) a))
(first (filter (fn [f] (= (:foo f) "bar")) a))
(first (filter (fn [f] (= (:foo f) "barrrr")) a))
#()
#([f] (+ 1 2))
#(f (+ 1 2))
# (+ 1 2))
#(+ 1 1)
a
(first #(= (:foo %) "bar") a))
(filter #(= (:foo %) "bar") a)
(declare foo)
foo
(def foo "a")
(def a {:foo {0 {:beep "boop"}}})
a
(require '[fleet :as f])
f
(require '[fleet :as f])
f
(require '[fleet :as f])
(f)
f/fleet
(f/fleet "foo <( bar )>")
(f/fleet [bar] "foo <( bar )>")
(def a (f/fleet [bar] "foo <( bar )>"))
a
(a "beep")
(prinln (a "beep")
)
(println (a "beep"))
((def footer (fleet "<p>&copy; <(year (now))> Your Company</p>")
))
(def footer (fleet "<p>&copy; <(year (now))> Your Company</p>"))
(def footer (f/fleet "<p>&copy; <(year (now))> Your Company</p>"))
(def header (f/fleet [title] "<head><title><(str title)></title></head>"))
(println (header "Main Page"))
(require '[hiccup.core :as h])
(h/html [:style])
(h/html [:style {:type "text/css"])
(h/html [:style {:type "text/css"}])
(count [])
(def a ["foo" "bar"])
(some #(= "foo" %) a)
(require '[fleet :as f])
(f/fleet [a b] "<(str a)><(str b)>")
((f/fleet [a b] "<(str a)><(str b)>") 1 2)
(str ((f/fleet [a b] "<(str a)><(str b)>") 1 2))
(str ((f/fleet [a b] "<(str a)>") 1 2))
(str ((f/fleet [a] "<(str a)>") 1 2))
(str ((f/fleet [a] "<(str a)>") 1))
a
(str ((f/fleet [aaa] "<(str a)>") 1))
(str ((f/fleet [aaa] "<(str aaa)>") 1))
(conj ["a"] ["b"])
(cons ["a"] ["b"])
(concat ["a"] ["b"])
(distinct ["a" "a" "b"])
(ns foo)
(def a (ns foo))
a
(re-find #"<\(include \"[^\"+]\")>" "goo")
(re-find #"<\(include \"[^\"+]\"\)>" "goo")
(re-find #"<\(include \"[^\"+]\"\)>" "foo<(include \"boop\")>")
(re-fine #'<\(include "(.+)"\)>' '<(include "boop")>)
"hello
"
'hello'
(re-fine #"<\(include \"(.+)\"\)>" "<(include \"boop\")>")
(re-find #"<\(include \"(.+)\"\)>" "<(include \"boop\")>")
(re-find #"<\(include \"(.+)\"\)>" "foo<(include \"boop\")>")
(re-find #"<\(include \"(.+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
(re-find #"<\(include \"([^"]+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
"
(re-find #"<\(include \"([^\"]+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
(re-seq #"<\(include \"([^\"]+)\"\)>" "foo<(include \"boop\")><(include \"beep\")>")
(second [1 2])
(partial + 1)
((partial + 1) 2)
(concat [1] [2] [3])
(def a [{:a [1 2 3]} {:a [4, 5, 6]}])
a
(reduce #(concat (:a %)) a)
(reduce conj a)
(reduce #(conj (:a %1) (:a %2)) a)
(reduce #(concat (:a %1) (:a %2)) a)
(require '[clojure.contrib.json :as f])
(require '[clojure.contrib.json :as j])
(require '[data.json :as j])
(require '[clojure.data.json :as j])
(doc print)
(vals {:a 1})
(require '[clojure.data.json :as j])
(def a 'hello')
a
(def a "{\"foo\": 1}")
a
(j/read-str a)
(def b (j/read-str a))
b
(:foo b)
(def b (j/read-str a :key-fn keyword))
b
